[{"title":"js继承","url":"https://zmkmb.github.io/2019/02/18/js继承/","content":"<h2 id=\"js继承\"><a href=\"#js继承\" class=\"headerlink\" title=\"js继承\"></a>js继承</h2><h4 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h4><p>基本思想就是，把子类的原型设置成父类的实例，这样子类就可以访问到父类原型上的方法，和属性。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//父类</span><br><span class=\"line\">function SuperType()&#123;</span><br><span class=\"line\">\tthis.name = &apos;super&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperType.prototype.sayName = function()&#123;</span><br><span class=\"line\">    console.log(this.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//子类</span><br><span class=\"line\">function SubType()&#123;</span><br><span class=\"line\">    this.name = &apos;sub&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SubType.prototype = new SuperType();</span><br></pre></td></tr></table></figure>\n<h4 id=\"构造函数继承\"><a href=\"#构造函数继承\" class=\"headerlink\" title=\"构造函数继承\"></a>构造函数继承</h4><p>基本实现是让父类在子类当中执行一遍，把this换成子类实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//父类</span><br><span class=\"line\">function SuperType()&#123;</span><br><span class=\"line\">\tthis.name = &apos;super&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperType.prototype.sayName = function()&#123;</span><br><span class=\"line\">    console.log(this.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//子类</span><br><span class=\"line\">function SubType()&#123;</span><br><span class=\"line\">    this.name = &apos;sub&apos;;</span><br><span class=\"line\">    SuperType.call(this);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h4><p>将原型链继承和借用构造函数继承组合到一起</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//父类</span><br><span class=\"line\">function SuperType()&#123;</span><br><span class=\"line\">\tthis.name = &apos;super&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperType.prototype.sayName = function()&#123;</span><br><span class=\"line\">    console.log(this.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//子类</span><br><span class=\"line\">function SubType()&#123;</span><br><span class=\"line\">    this.name = &apos;sub&apos;;</span><br><span class=\"line\">    SuperType.call(this);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SubType.prototype = new SuperType();</span><br><span class=\"line\">SubType.prototype.constructor = SubType;//从新设置原型对象上构造函数属性</span><br></pre></td></tr></table></figure>\n<h4 id=\"寄生组合式继承\"><a href=\"#寄生组合式继承\" class=\"headerlink\" title=\"寄生组合式继承\"></a>寄生组合式继承</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//父类</span><br><span class=\"line\">function SuperType()&#123;</span><br><span class=\"line\">\tthis.name = &apos;super&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperType.prototype.sayName = function()&#123;</span><br><span class=\"line\">    console.log(this.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//子类</span><br><span class=\"line\">function SubType()&#123;</span><br><span class=\"line\">    this.name = &apos;sub&apos;;</span><br><span class=\"line\">    SuperType.call(this);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var prototype = Object(SuperType.prototype);</span><br><span class=\"line\">prototype.constructor = SubType;</span><br><span class=\"line\">SubType.prototype = prototype;</span><br></pre></td></tr></table></figure>\n","categories":["前端"],"tags":["js"]},{"title":"tcp三次握手和四次挥手","url":"https://zmkmb.github.io/2018/11/19/tcp三次握手和四次挥手/","content":"<h4 id=\"首先了解一些概念\"><a href=\"#首先了解一些概念\" class=\"headerlink\" title=\"首先了解一些概念\"></a>首先了解一些概念</h4><ul>\n<li><p>SYN 表示建立连接</p>\n</li>\n<li><p>FIN 表示关闭连接</p>\n</li>\n<li><p>ACK 表示确认</p>\n</li>\n</ul>\n<h4 id=\"tcp连接为什么会有三次握手\"><a href=\"#tcp连接为什么会有三次握手\" class=\"headerlink\" title=\"tcp连接为什么会有三次握手\"></a>tcp连接为什么会有三次握手</h4><p>通信双方，建立连接时，彼此知道自己和对方的发送和接收处于正常状态，至少需要三次通信。</p>\n<a id=\"more\"></a>\n<p>假设客户端为c,服务端为s</p>\n<p>1.客户c端向服务端s发送SYN=1</p>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th>客户端</th>\n<th>服务端</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>客户端发送</td>\n<td>正常</td>\n<td>未知</td>\n</tr>\n<tr>\n<td>客户端接收</td>\n<td>未知</td>\n<td>未知</td>\n</tr>\n<tr>\n<td>服务端发送</td>\n<td>未知</td>\n<td>未知</td>\n</tr>\n<tr>\n<td>服务端接收</td>\n<td>未知</td>\n<td>未知</td>\n</tr>\n</tbody>\n</table>\n<p>2.服务端s响应SYN=1 ACK=1</p>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th>客户端</th>\n<th>服务端</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>客户端发送</td>\n<td>正常</td>\n<td>正常</td>\n</tr>\n<tr>\n<td>客户端接收</td>\n<td>未知</td>\n<td>未知</td>\n</tr>\n<tr>\n<td>服务端发送</td>\n<td>未知</td>\n<td>正常</td>\n</tr>\n<tr>\n<td>服务端接收</td>\n<td>未知</td>\n<td>正常</td>\n</tr>\n</tbody>\n</table>\n<p>3.客户c端收到响应后向服务端发送消息ACK=1</p>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th>客户端</th>\n<th>服务端</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>客户端发送</td>\n<td>正常</td>\n<td>正常</td>\n</tr>\n<tr>\n<td>客户端接收</td>\n<td>正常</td>\n<td>未知</td>\n</tr>\n<tr>\n<td>服务端发送</td>\n<td>正常</td>\n<td>正常</td>\n</tr>\n<tr>\n<td>服务端接收</td>\n<td>正常</td>\n<td>正常</td>\n</tr>\n</tbody>\n</table>\n<p>4.服务端收到消息双方建立连接</p>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th>客户端</th>\n<th>服务端</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>客户端发送</td>\n<td>正常</td>\n<td>正常</td>\n</tr>\n<tr>\n<td>客户端接收</td>\n<td>正常</td>\n<td>正常</td>\n</tr>\n<tr>\n<td>服务端发送</td>\n<td>正常</td>\n<td>正常</td>\n</tr>\n<tr>\n<td>服务端接收</td>\n<td>正常</td>\n<td>正常</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"为什么会有四次挥手\"><a href=\"#为什么会有四次挥手\" class=\"headerlink\" title=\"为什么会有四次挥手\"></a>为什么会有四次挥手</h4><ul>\n<li>由于tcp是全双工通信，所以通信双方需要确认对方的数据已经发送完，以及自己最后发送的数据已经被对方接受到。</li>\n</ul>\n<p>假设客户端为c,服务端为s，客户端发送断开请求</p>\n<p>1.客户端向服务端发送FIN=1</p>\n<p>2.服务端收到请求，向服务端发送确认ACK=1</p>\n<p>3.服务端继续发送数据，如果数据发送完，向客户端发送关闭请求FIN=1</p>\n<p>4.客户端收到关闭请求，接收完数据后发送确认ACK=1</p>\n<p>如果第2步服务端发送确认请求时，已经没有数据发往客户端，可以同时发送关闭请求。这时候第2步和第3步可以合为一步。</p>\n<p>我们可以看到建立连接的时候，服务端确认请求，和建立连接请求是合在一起发送给客户端的。所以断开连接一般会比建立连接多一次。</p>\n","categories":["网络"],"tags":["网络"]},{"title":"跨域问题","url":"https://zmkmb.github.io/2018/11/10/跨域问题/","content":"<h5 id=\"为什么有跨域？\"><a href=\"#为什么有跨域？\" class=\"headerlink\" title=\"为什么有跨域？\"></a>为什么有跨域？</h5><p>它是由浏览器的同源策略造成的，这是浏览器的安全机制，如果你定制一个浏览器，不去判断是否跨域，就没有跨域的问题。比如我们在后台使用curl模拟http请求，就不会有跨域的问题。</p>\n<h5 id=\"哪些属于跨域？\"><a href=\"#哪些属于跨域？\" class=\"headerlink\" title=\"哪些属于跨域？\"></a>哪些属于跨域？</h5><p>协议、主机地址以及端口，任何一项不同都会被认为是跨域<br><a id=\"more\"></a></p>\n<h5 id=\"跨域的请求是否被发送出去？\"><a href=\"#跨域的请求是否被发送出去？\" class=\"headerlink\" title=\"跨域的请求是否被发送出去？\"></a>跨域的请求是否被发送出去？</h5><p>跨域请求分为两种，简单请求和预检请求</p>\n<p>如果是简单请求，浏览器会直接发送。<br>如果是预检请求，首先浏览器发送一个预检请求，如果响应成功，才或把真实请求发出。</p>\n<h5 id=\"什么时候会触发预检请求？\"><a href=\"#什么时候会触发预检请求？\" class=\"headerlink\" title=\"什么时候会触发预检请求？\"></a>什么时候会触发预检请求？</h5><p>当请求满足下述任一条件时，即应首先发送预检请求：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用了下面任一 HTTP 方法：</span><br><span class=\"line\">PUT</span><br><span class=\"line\">DELETE</span><br><span class=\"line\">CONNECT</span><br><span class=\"line\">OPTIONS</span><br><span class=\"line\">TRACE</span><br><span class=\"line\">PATCH</span><br><span class=\"line\">人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为：</span><br><span class=\"line\">Accept</span><br><span class=\"line\">Accept-Language</span><br><span class=\"line\">Content-Language</span><br><span class=\"line\">Content-Type (but note the additional requirements below)</span><br><span class=\"line\">DPR</span><br><span class=\"line\">Downlink</span><br><span class=\"line\">Save-Data</span><br><span class=\"line\">Viewport-Width</span><br><span class=\"line\">Width</span><br><span class=\"line\"> Content-Type 的值不属于下列之一:</span><br><span class=\"line\">application/x-www-form-urlencoded</span><br><span class=\"line\">multipart/form-data</span><br><span class=\"line\">text/plain</span><br></pre></td></tr></table></figure>\n<h5 id=\"如何解决？\"><a href=\"#如何解决？\" class=\"headerlink\" title=\"如何解决？\"></a>如何解决？</h5><ul>\n<li>jsonp</li>\n</ul>\n<p>由于在浏览器中我们可以引用外部的js,这样我们通过修改script标签中js的地址，和服务端返回的js文件的内容。就可以从跨域服务器<br>获取数据。<br>优点是兼容性好，缺点是只能发生get请求。</p>\n<ul>\n<li>代理</li>\n</ul>\n<p>我们可以访问同源的服务器，通过服务器发送跨域请求</p>\n<ul>\n<li>cors</li>\n</ul>\n<p>跨域请求分为两种，简单请求和预检请求</p>\n<p>如果是简单请求，在服务端响应头设置<br>Access-Control-Allow-Origin属性。属性值是允许跨域的来源，如果值为 * 则表示允许所有来源。</p>\n<p>如果是预检请求，需要服务端处理预检请求</p>\n<ul>\n<li>websocket</li>\n</ul>\n","categories":[],"tags":["js 浏览器"]},{"title":"前端调试方法总结","url":"https://zmkmb.github.io/2018/11/09/前端调试方法总结/","content":"<h4 id=\"代理工具\"><a href=\"#代理工具\" class=\"headerlink\" title=\"代理工具\"></a>代理工具</h4><p>Charles</p>\n<p>anyproxy</p>\n<p><a href=\"https://github.com/alibaba/anyproxy\" target=\"_blank\" rel=\"noopener\">https://github.com/alibaba/anyproxy</a></p>\n<p>AnyProxy是一个基于NodeJS的，可供插件配置的HTTP/HTTPS代理服务器。我们可以在服务器返回的数据中插入我们的js代码。利用AnyProxy我们可以做一些有趣的事情，比如抓取微信公众号文章的阅读量，和点赞数。</p>\n<p>如果需要查看https协议的内容，需要手机安装相关的证书，并信任。</p>\n<a id=\"more\"></a>\n<h4 id=\"手机移动端页面调试\"><a href=\"#手机移动端页面调试\" class=\"headerlink\" title=\"手机移动端页面调试\"></a>手机移动端页面调试</h4><h5 id=\"微信\"><a href=\"#微信\" class=\"headerlink\" title=\"微信\"></a>微信</h5><p>微信公众号，和微信小程序开发，可以使用微信提供的开发者工具<br><a href=\"https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html\" target=\"_blank\" rel=\"noopener\">https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html</a></p>\n<h5 id=\"安卓系统\"><a href=\"#安卓系统\" class=\"headerlink\" title=\"安卓系统\"></a>安卓系统</h5><p>1.安卓手机打开调试模式，使用数据线连接电脑</p>\n<p>2.用手机默认浏览器打开需要调试的网页</p>\n<p>3.电脑上打开谷歌浏览器，在输入框中输入chrome://inspect/#devices</p>\n<p>app内嵌网页调试需要调试的app处于可调试模式。其他和浏览器中调试一样。</p>\n<p>另外这种方式需要科学上网。</p>\n<h5 id=\"ios系统\"><a href=\"#ios系统\" class=\"headerlink\" title=\"ios系统\"></a>ios系统</h5><p>苹果电脑Safari 设置</p>\n<p>打开Safari偏好者设置，选中“高级菜单”，在页面最下方看到“在菜单中显示开发菜单”的复选框，勾选。</p>\n<p>iphone手机设置</p>\n<p>打开iPhone手机设置app 选择Safari，找到高级选项，有JavaScript开关web检查器开关，将两个开关都打开</p>\n<p>1.手机数据线连接电脑</p>\n<p>2.用手机safrai浏览器打开需要调试的网页</p>\n<p>3.苹果电脑上打开safrai浏览器在开发菜单中选择连接的手机</p>\n<p>app内嵌网页调试跟安卓一样，需要app处于可调试模式。</p>\n<h4 id=\"weinre\"><a href=\"#weinre\" class=\"headerlink\" title=\"weinre\"></a>weinre</h4><p><a href=\"http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html\" target=\"_blank\" rel=\"noopener\">http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html</a></p>\n<h5 id=\"JSCompress\"><a href=\"#JSCompress\" class=\"headerlink\" title=\"JSCompress\"></a>JSCompress</h5><p><a href=\"https://www.jscompress.cn/\" target=\"_blank\" rel=\"noopener\">https://www.jscompress.cn/</a></p>\n<h5 id=\"eruda\"><a href=\"#eruda\" class=\"headerlink\" title=\"eruda\"></a>eruda</h5><p><a href=\"https://github.com/liriliri/eruda\" target=\"_blank\" rel=\"noopener\">https://github.com/liriliri/eruda</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;//cdn.jsdelivr.net/npm/eruda&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;eruda.init();&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"vConsole\"><a href=\"#vConsole\" class=\"headerlink\" title=\"vConsole\"></a>vConsole</h5><p><a href=\"https://github.com/Tencent/vConsole\" target=\"_blank\" rel=\"noopener\">https://github.com/Tencent/vConsole</a></p>\n<p>eruda和vConsole都是用js实现了一个调试面板。在自己的项目中引用js并初始化，就可以在前端页面查看日志，请求数据等一些信息。甚至可以像在pc浏览器中一样，在console下执行js代码。缺点是不能打断点，也不能实时的修改样式。</p>\n","categories":["前端"],"tags":["前端"]},{"title":"nodejs调试","url":"https://zmkmb.github.io/2018/10/28/nodejs调试/","content":"<h2 id=\"nodejs调试\"><a href=\"#nodejs调试\" class=\"headerlink\" title=\"nodejs调试\"></a>nodejs调试</h2><ul>\n<li><p>第三方模块</p>\n<p>npm install node-inspector -g</p>\n<p>npm install devtool -g</p>\n</li>\n<li><p>开发工具调试<br>vscod<br>webStorm</p>\n</li>\n<li><p>Node 原生调试</p>\n</li>\n</ul>\n<a id=\"more\"></a>","categories":["nodejs"],"tags":["nodejs"]},{"title":"防抖和节流","url":"https://zmkmb.github.io/2018/10/28/防抖和节流/","content":"<h2 id=\"防抖和节流\"><a href=\"#防抖和节流\" class=\"headerlink\" title=\"防抖和节流\"></a>防抖和节流</h2><ul>\n<li>什么是防抖？</li>\n</ul>\n<p>只看字面意思很难让人理解，至少我刚接触到这个名词的时候会把防抖和节流混淆。</p>\n<p>最好的理解方式是把它关联到一个应用场景中。举个例子，有一个需求，在搜索框里输入文字时，实时的向后台请求数据，展示在内容区。我们知道当用户输入时会频繁的触发输入事件，这时短时间大量的请求会给后台造成很大压力，而且有一部分请求是没有必要的。我们可以对触发的请求做一个延时，当用户停止触发输入事件后一段时间，才去发送请求。</p>\n<a id=\"more\"></a>\n<ul>\n<li>代码实现</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(fun,delay)&#123;</span><br><span class=\"line\">    var timer = null;</span><br><span class=\"line\">    return function()&#123;</span><br><span class=\"line\">        var that = this;</span><br><span class=\"line\">        var args = arguments;</span><br><span class=\"line\">        clearTimeout(timer);</span><br><span class=\"line\">        timer = setTimeout(function()&#123;</span><br><span class=\"line\">            fun(that,args);</span><br><span class=\"line\">        &#125;,delay);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>节流</li>\n</ul>\n<p>有时候我们想要在连续调用一个函数时，每隔一段时间触发一次。比如我们玩游戏时连续点击鼠标但是确是按固定频率触发攻击。</p>\n<ul>\n<li>代码实现</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">简单版： 定时器期间，只执行最后一次操作</span><br><span class=\"line\">var throttling = (fn, wait) =&gt; &#123;</span><br><span class=\"line\">\tlet timer;</span><br><span class=\"line\">\tlet context, args;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tlet run = () =&gt; &#123;</span><br><span class=\"line\">\t\ttimer=setTimeout(()=&gt;&#123;</span><br><span class=\"line\">\t\t\tfn.apply(context,args);</span><br><span class=\"line\">\t\t\tclearTimeout(timer);</span><br><span class=\"line\">\t\t\ttimer=null;</span><br><span class=\"line\">\t\t&#125;,wait);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\treturn function () &#123;</span><br><span class=\"line\">\t\tcontext=this;</span><br><span class=\"line\">\t\targs=arguments;</span><br><span class=\"line\">\t\tif(!timer)&#123;</span><br><span class=\"line\">\t\t\tconsole.log(&quot;throttle, set&quot;);</span><br><span class=\"line\">\t\t\trun();</span><br><span class=\"line\">\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\tconsole.log(&quot;throttle, ignore&quot;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["js"],"tags":["js"]},{"title":"nodejs模块化","url":"https://zmkmb.github.io/2018/10/28/nodejs模块化/","content":"<h2 id=\"nodejs模块化\"><a href=\"#nodejs模块化\" class=\"headerlink\" title=\"nodejs模块化\"></a>nodejs模块化</h2><p>  nodejs模块化采用CommonJs规范</p>\n<ul>\n<li><p>导出模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//a.js</span><br><span class=\"line\">module.exports = function () &#123;</span><br><span class=\"line\">    console.log(&apos;Hello World!&apos;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//b.js</span><br><span class=\"line\">exports.hello = function()&#123;</span><br><span class=\"line\">    console.log(&apos;Hello Workd!&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//c.js</span><br><span class=\"line\">module.exports.hello = function()&#123;</span><br><span class=\"line\">    console.log(&apos;Hello Workd!&apos;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><p>导入模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = require(&apos;./a.js&apos;);</span><br><span class=\"line\">a();//&apos;Hello World!&apos;</span><br><span class=\"line\">var b = require(&apos;./b.js&apos;);</span><br><span class=\"line\">b.hello();//&apos;Hello World!&apos;</span><br><span class=\"line\">var c = require(&apos;./c.js&apos;);</span><br><span class=\"line\">c.hello();//&apos;Hello World!&apos;</span><br></pre></td></tr></table></figure>\n<p>推荐使用module.exports导出模块，exports实际上是module.exports的引用。</p>\n</li>\n<li><p>注意</p>\n<p>一个模块中的JS代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出对象被重复利用。</p>\n<h3 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h3></li>\n<li><p>a.js 和 b.js 两个文件互相 require 是否会死循环? 双方是否能导出变量? 如何从设计上避免这种问题? </p>\n<p>不会死循环，以从 a.js 启动为例, a.js 还没执行完会返回一个 a.js 的 exports 对象的 未完成的副本 给 b.js 模块。 然后 b.js 完成加载，并将 exports 对象提供给 a.js 模块</p>\n</li>\n<li><p>如果 a.js require 了 b.js, 那么在 b 中定义全局变量 t = 111 能否在 a 中直接打印出来?</p>\n<p>可以，每一个模块相当于被nodejs在外包裹了一个自执行函数，内部声明的变量外部无法访问，但是全局变量可以被访问到</p>\n</li>\n<li><p>如何在不重启 node 进程的情况下热更新一个 js/json 文件? 这个问题本身是否有问题?</p>\n<p>可以清除掉 require.cache 的缓存重新 require(xxx),使用 js 实现热更新很容易碰到 v8 优化之后各地拿到缓存的引用导致热更新 js 没意义</p>\n</li>\n</ul>\n","categories":["nodejs"],"tags":["nodejs"]},{"title":"从输入URL到浏览器显示页面发生了什么","url":"https://zmkmb.github.io/2018/10/28/从输入url到浏览器显示页面发生了什么/","content":"<h5 id=\"DNS解析\"><a href=\"#DNS解析\" class=\"headerlink\" title=\"DNS解析\"></a>DNS解析</h5><p>首先浏览器会取缓存，如果没有，则取操作系统的hosts文件里域名对应的ip地址。</p>\n<p>如果hosts里也找不到，浏览器就会请求dns获取对应的ip。</p>\n<a id=\"more\"></a>\n<p>有时候我们会发现，相同的域名对应的ip有多个。这是因为对于一些访问量大的网站，应用部署在不同的服务器上的。这是候设置dns轮询，或者采用智能dns,返回就近的ip地址。可以把请求相对均匀的分布到不同的服务器上。</p>\n<p>有时候我们会手动修改操作系统的hosts文件，去访问一些404的网站。不过现在这种方式应该也不能用了。</p>\n<h5 id=\"建立tcp连接\"><a href=\"#建立tcp连接\" class=\"headerlink\" title=\"建立tcp连接\"></a>建立tcp连接</h5><p>http处于网络协议的应用层，并且基于tcp。<br>浏览器根据url生成一个http请求。向服务器发出请求时首先会建立tcp连接。<br>除了http协议，现在很多网站都采用https协议，相对于http来说会更复杂一点。<br>当然未来还有http2协议。</p>\n<p><a href=\"\">tcp三次握手四次挥手</a></p>\n<h5 id=\"服务器接收请求并响应\"><a href=\"#服务器接收请求并响应\" class=\"headerlink\" title=\"服务器接收请求并响应\"></a>服务器接收请求并响应</h5><p>服务器端一般会采用nginx,做负载均衡。</p>\n<p>nginx接收到请求，根据配置文件，把请求转发到不同的后端服务上去。</p>\n<p>后端服务收到请求，做一些运算或io操作，拿到数据，然后返回数据。</p>\n<h5 id=\"浏览器渲染\"><a href=\"#浏览器渲染\" class=\"headerlink\" title=\"浏览器渲染\"></a>浏览器渲染</h5><p>1.浏览器将HTML解析成一个DOM树</p>\n<p>2.将CSS解析成 CSS Rule Tree </p>\n<p>3.根据DOM树和CSSOM来构造 Rendering Tree</p>\n<p>4.遍历render树，并使用UI后端层绘制每个节点</p>\n<p>前端开发中这一部分我们关注的是</p>\n<p><a href=\"\">减少重绘(redraw)和重排(reflow)</a></p>\n<p><a href=\"\">资源加载对页面的渲染的影响</a></p>\n","categories":["浏览器"],"tags":["前端"]},{"title":"js中带var和不带var的区别","url":"https://zmkmb.github.io/2018/10/09/js中带var和不带var的区别/","content":"<p>js中使用var来声明一个变量。</p>\n<p>并且在全局作用域下变量是window的一个属性</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(a)//undifind</span><br><span class=\"line\">console.log(window.a)//undifind</span><br><span class=\"line\">console.log(&apos;a&apos; in window) //true</span><br><span class=\"line\">var a = 1;</span><br><span class=\"line\">console.log(a);//1</span><br><span class=\"line\">console.log(window.a)//1</span><br></pre></td></tr></table></figure>\n<p>如果变量没有使用var声明，相当于在window上添加了一个属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(b)//js报错</span><br><span class=\"line\">console.log(window.b)//undifind</span><br><span class=\"line\">console.log(&apos;b&apos; in window) //false</span><br><span class=\"line\">b = 1;</span><br><span class=\"line\">console.log(b);//1</span><br><span class=\"line\">console.log(window.b)//1</span><br></pre></td></tr></table></figure>\n<p>两者的区别是var声明的变量会有变量提升。</p>\n<p>严格模式下一个变量没有声明就被赋值，js会执行错误。</p>\n<p>var a = 1,b=2;相当于var a = 1;var b = 2;</p>\n<p>var a = b = 1;相当于var a = 1;b = 1; </p>\n","categories":["前端"],"tags":["js"]},{"title":"实现网页截图的几种方案","url":"https://zmkmb.github.io/2018/07/09/实现网页截图的几种方案/","content":"<h3 id=\"网页截图方案\"><a href=\"#网页截图方案\" class=\"headerlink\" title=\"网页截图方案\"></a>网页截图方案</h3><p>项目当中有一个需求是把当前页面截图，并在截图上添加二维码效果</p>\n<p>这里简单介绍一下几种截图的方案，更详细的内容大家可以根据关键词搜索，找到相关介绍</p>\n<h4 id=\"截图方案分为两种\"><a href=\"#截图方案分为两种\" class=\"headerlink\" title=\"截图方案分为两种\"></a>截图方案分为两种</h4><p>一种是前端通过js通过遍历相关dom,生产canvas,并通过canvas生成图片</p>\n<p>另一种是服务端调取一些无头浏览器的截图接口生成截图</p>\n<a id=\"more\"></a>\n<p>前端</p>\n<p>1.dom-to-image</p>\n<p>git地址 <a href=\"https://github.com/tsayen/dom-to-image\" target=\"_blank\" rel=\"noopener\">https://github.com/tsayen/dom-to-image</a></p>\n<p>2.html2canvas</p>\n<p>git地址 <a href=\"https://github.com/niklasvh/html2canvas\" target=\"_blank\" rel=\"noopener\">https://github.com/niklasvh/html2canvas</a></p>\n<p>使用前端截图，需要注意的是css的兼容性，有一些css3样式，或者svg图表会有兼容性问题,会导致截图和页面显示不一致</p>\n<p>后台</p>\n<ol>\n<li>xvfb cutycapt</li>\n<li>vian（基于puppeteer，命令行）</li>\n<li>puppeteer</li>\n<li>PhantomJS</li>\n</ol>\n<p>这里介绍一下phantomjs</p>\n<p>PhantomJS 下载地址</p>\n<p><a href=\"http://phantomjs.org/download.html\" target=\"_blank\" rel=\"noopener\">http://phantomjs.org/download.html</a></p>\n<p>这里以linux64 为例</p>\n<p>1.wget <a href=\"http://bitbucket.org/ariya/phantomjs/downloads/phantomjs-2.1.1-linux-x86_64.tar.bz2\" target=\"_blank\" rel=\"noopener\">http://bitbucket.org/ariya/phantomjs/downloads/phantomjs-2.1.1-linux-x86_64.tar.bz2</a> –no-check-certificate</p>\n<p>2.sudo tar -xvf phantomjs-2.1.1-linux-x86_64.tar.bz2</p>\n<p>3.解压后文件里有examples文件夹里有使用用例</p>\n<p>由于Chromium无头版本的推出，Phantom.js已经不再维护，使用puppeteer也可以实现相同效果</p>\n<p>后台截图需要注意的是网页上的一些svg动画可能截取不到，或者网页加载慢会导致截图不完整。</p>\n","categories":[],"tags":["前端"]},{"title":"css权重","url":"https://zmkmb.github.io/2018/06/10/css权重/","content":"<h3 id=\"css-中有不同的选择器，不同的选择器拥有不同的优先级\"><a href=\"#css-中有不同的选择器，不同的选择器拥有不同的优先级\" class=\"headerlink\" title=\"css 中有不同的选择器，不同的选择器拥有不同的优先级\"></a>css 中有不同的选择器，不同的选择器拥有不同的优先级</h3><p>!important  Infinity //优先级最高</p>\n<p>行内样式        1000</p>\n<p>id               100</p>\n<p>class |属性|伪类   10</p>\n<p>标签|伪元素        1</p>\n<p>通配符             0</p>\n<p>作用在同一个元素上的选择器，优先级高的生效。 如果优先级相同则靠后的生效</p>\n<p>注意10个标签选择器优先级没有1个class选择器高，选择器之间并不是简单的十进制，有资料说进制为256。</p>\n<a id=\"more\"></a>","categories":["前端"],"tags":["css"]},{"title":"flex布局","url":"https://zmkmb.github.io/2018/06/10/flex布局/","content":"<h3 id=\"flex布局\"><a href=\"#flex布局\" class=\"headerlink\" title=\"flex布局\"></a>flex布局</h3><p>flex是CSS3中新添加的属性。比起之前的浮动布局更具有灵活性</p>\n<p>在不考虑IE,及低版本安卓系统的兼容下，可以放心使用</p>\n<a id=\"more\"></a>\n<ul>\n<li>flex容器属性<ul>\n<li>flex-flow</li>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content</li>\n</ul>\n</li>\n<li>flex元素属性<ul>\n<li>order</li>\n<li>flex-grow</li>\n<li>flex-shrink</li>\n<li>flex-basis</li>\n<li>flex</li>\n<li>align-self</li>\n</ul>\n</li>\n</ul>\n<p>首先每一个弹性容器都有两根轴，主轴和交叉轴</p>\n<ul>\n<li><p>flex-direction</p>\n<p>flex-direction用来设定主轴的方向,容器内的子元素会根据主轴方向来排列</p>\n<ul>\n<li>row(默认):水平</li>\n<li>column：垂直</li>\n<li>row-reverse</li>\n<li>column-reverse</li>\n</ul>\n</li>\n<li><p>flex-wrap</p>\n<p>flex-wrap用来设定，容器中的子元素在主轴方向排不下的情况向如何显示</p>\n<ul>\n<li>nowrap(默认)：不换行</li>\n<li>wrap：折行</li>\n<li>wrap-reverse：反向折行</li>\n</ul>\n</li>\n<li><p>flex-flow</p>\n<p>复合属性相当于flex-direction + flex-wrap</p>\n</li>\n<li><p>justify-content </p>\n<p>主轴方向的对齐方式</p>\n</li>\n<li><p>align-items</p>\n<p>交叉轴方向的对齐方式</p>\n</li>\n<li><p>flex-order</p>\n<p>设置元素之间的排序，数值越小越靠前</p>\n</li>\n<li><p>flex-grow</p>\n<p>当flex-wrap为nowrap时，子元素在主轴方向没有排满时，可以用flex-grow来控制子元素的显示</p>\n<p>默认是0，不放大</p>\n</li>\n<li><p>flex-shrink</p>\n<p>当flex-wrap为nowrap时，子元素在主轴方向排满超出时，可以用flex-shrink来控制子元素的显示</p>\n<p>默认是1，按比例缩放</p>\n</li>\n<li><p>flex-basis</p>\n<p>flex-basis设置元素在主轴上的初始尺寸，也就是flex-grow和flex-shrink生效前的尺寸</p>\n<ul>\n<li>如果为0，根据内容撑开</li>\n<li>如果非0，优先级大于width</li>\n<li>如果为auto，优先取width，没有则根据内容决定</li>\n</ul>\n</li>\n<li><p>flex</p>\n<p>flex-grow, flex-shrink, flex-basis 的复合属性</p>\n<p>flex:1 = flex:1 1 0</p>\n<p>flex:auto = flex:1 1 auto</p>\n<p>flex:none = flex:0 0 auto</p>\n</li>\n</ul>\n","categories":["前端"],"tags":["css"]},{"title":"css行高","url":"https://zmkmb.github.io/2018/06/10/css行高/","content":"<h3 id=\"line-height-分为有单位和无单位\"><a href=\"#line-height-分为有单位和无单位\" class=\"headerlink\" title=\"line-height 分为有单位和无单位\"></a>line-height 分为有单位和无单位</h3><p>line-height 有一个默认值一般为1.2</p>\n<h4 id=\"有单位值\"><a href=\"#有单位值\" class=\"headerlink\" title=\"有单位值\"></a>有单位值</h4><p>px,em,%属于无单位值。这时候子元素的行高继承父元素的行高值，行高值是根据父元素的字体大小计算的结果</p>\n<a id=\"more\"></a>\n<h4 id=\"无单位值\"><a href=\"#无单位值\" class=\"headerlink\" title=\"无单位值\"></a>无单位值</h4><p>行高可以是一个数字，这时候子元素继承这个数值。<br>根据子元素的字体大小来计算行高。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">.box1&#123;font-size:30px;line-height:120%;&#125;</span><br><span class=\"line\">.box2&#123;font-size:30px;line-height:1.2;&#125;</span><br><span class=\"line\">p&#123;font-size:16px;background-color:#bfc;&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--子元素的行高是 16*1.2--&gt;</span><br><span class=\"line\">&lt;div class=&quot;box1&quot;&gt;</span><br><span class=\"line\">&lt;p&gt;abcdefg&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!--子元素的行高是30*120% --&gt;</span><br><span class=\"line\">&lt;div class=&quot;box2&quot;&gt;</span><br><span class=\"line\">&lt;p&gt;abcdefg&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n","categories":["前端"],"tags":["css"]},{"title":"前端常见问题总结","url":"https://zmkmb.github.io/2018/06/09/前端常见问题总结/","content":"<h3 id=\"安卓-4-4-4-ios低版本没有Object-assign-方法\"><a href=\"#安卓-4-4-4-ios低版本没有Object-assign-方法\" class=\"headerlink\" title=\"安卓(4.4.4),ios低版本没有Object.assign()方法\"></a>安卓(4.4.4),ios低版本没有Object.assign()方法</h3><h3 id=\"ios-返回js不执行\"><a href=\"#ios-返回js不执行\" class=\"headerlink\" title=\"ios 返回js不执行\"></a>ios 返回js不执行</h3><p>window.onpageshow = function (e) {<br> if (e.persisted) {<br>​       window.location.reload(true)<br> }<br>}</p>\n<a id=\"more\"></a>\n<h3 id=\"ipad-pro-获取屏幕宽度失败。\"><a href=\"#ipad-pro-获取屏幕宽度失败。\" class=\"headerlink\" title=\"ipad pro 获取屏幕宽度失败。\"></a>ipad pro 获取屏幕宽度失败。</h3><p>screen.width 获取结果是320</p>\n<h3 id=\"部分谷歌浏览器-document-body-scrollTop-等于0\"><a href=\"#部分谷歌浏览器-document-body-scrollTop-等于0\" class=\"headerlink\" title=\"部分谷歌浏览器 document.body.scrollTop 等于0\"></a>部分谷歌浏览器 document.body.scrollTop 等于0</h3><p>兼容方式</p>\n<p>var heightTop = document.documentElement.scrollTop || document.body.scrollTop;</p>\n<h3 id=\"安卓手机滑动不流畅\"><a href=\"#安卓手机滑动不流畅\" class=\"headerlink\" title=\"安卓手机滑动不流畅\"></a>安卓手机滑动不流畅</h3><p>touch-action:pan-y</p>\n<h3 id=\"vue-在iOS系统中返回，页面空白问题\"><a href=\"#vue-在iOS系统中返回，页面空白问题\" class=\"headerlink\" title=\"vue 在iOS系统中返回，页面空白问题\"></a>vue 在iOS系统中返回，页面空白问题</h3><p>拿到数据之后:<br>this.$nextTick(() =&gt; {<br>​    window.scrollTo(0, 1)<br>​    window.scrollTo(0, 0)<br>})；</p>\n","categories":["前端"],"tags":["前端"]},{"title":"树莓派实现远程视频监控","url":"https://zmkmb.github.io/2018/06/09/树莓派实现远程视频监控/","content":"<ul>\n<li>准备<br>树莓派，usb摄像头</li>\n<li>使用montion<ul>\n<li>安装montion<br>sudo apt-get install motion</li>\n<li>修改motion配置<br>sudo nano /etc/motion/motion.conf<br>将on改为off<br>stream_localhost off<br>这样就可以在局域网的其他设备上访问motion服务<br>其他配置还可以修改摄像画面的分辨率等</li>\n<li>启动motion<br>sudo motion</li>\n</ul>\n</li>\n</ul>\n<p>在局域网里打开浏览器，在地址栏输入树莓派的ip地址端口号默认为8081,查看监控画面</p>\n","categories":[],"tags":["树莓派"]},{"title":"js严格模式","url":"https://zmkmb.github.io/2018/03/28/js严格模式/","content":"<h2 id=\"js严格模式\"><a href=\"#js严格模式\" class=\"headerlink\" title=\"js严格模式\"></a>js严格模式</h2><h4 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h4><p>在脚本前加”use strict”;</p>\n<a id=\"more\"></a>\n<h4 id=\"有哪些变化\"><a href=\"#有哪些变化\" class=\"headerlink\" title=\"有哪些变化\"></a>有哪些变化</h4><p>1.变量必须显式声明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;use strict&quot;</span><br><span class=\"line\">//下面变量声明会报错</span><br><span class=\"line\">a = 1</span><br></pre></td></tr></table></figure>\n<p>2.this默认是undefined</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;use strict&quot;</span><br><span class=\"line\">function a ()&#123;</span><br><span class=\"line\">    console.log(this)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()//非严格模式是window,严格模式是undefinded</span><br></pre></td></tr></table></figure>\n<p>3.严格模式要求函数的参数名唯一</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;use strict&quot;</span><br><span class=\"line\">//下面函数声明会报错</span><br><span class=\"line\">function (a,a)&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4.不可以用with</p>\n<p>5.禁止八进制数字语法</p>\n<p>6.不再支持 arguments.callee</p>\n<p>7.参数的值不会随 arguments 对象的值的改变而变化<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fn1(a)&#123;</span><br><span class=\"line\">  arguments[0] = 2;</span><br><span class=\"line\">  console.log(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function fn2(a)&#123;</span><br><span class=\"line\"> &quot;use strict&quot;</span><br><span class=\"line\">  arguments[0] = 2;</span><br><span class=\"line\">  console.log(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn1(1)//2</span><br><span class=\"line\">fn2(1)//1</span><br></pre></td></tr></table></figure></p>\n<p>  。。。</p>\n<h4 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><p>如果合并脚本，严格模式会导致，一些没用采用严格模式的脚本出错，所以使用时最好用一个函数把代码包裹器来。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode</a></p>\n","categories":["前端"],"tags":["js"]},{"title":"js中this的指向","url":"https://zmkmb.github.io/2018/03/28/js中this的指向/","content":"<h2 id=\"js中this的指向\"><a href=\"#js中this的指向\" class=\"headerlink\" title=\"js中this的指向\"></a>js中this的指向</h2><h4 id=\"除了箭头函数，js中this的指向是在js执行过程中确定的\"><a href=\"#除了箭头函数，js中this的指向是在js执行过程中确定的\" class=\"headerlink\" title=\"除了箭头函数，js中this的指向是在js执行过程中确定的\"></a>除了箭头函数，js中this的指向是在js执行过程中确定的</h4><p>一个函数的执行环境不同那它内部this的指向也不同。<br><a id=\"more\"></a></p>\n<h3 id=\"this的指向分几种情况\"><a href=\"#this的指向分几种情况\" class=\"headerlink\" title=\"this的指向分几种情况\"></a>this的指向分几种情况</h3><p>1.标签中声明的事件的回调函数里的this指向元素本身</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--this指向元素本身--&gt;</span><br><span class=\"line\">&lt;div onclick=&quot;console.log(this)&quot;&gt;点我&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>2.普通函数执行，看函数是否作为对象的属性。函数作为对象属性的时候执行时this指向该对象，否则this指向window</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &#123;</span><br><span class=\"line\">    fn:function()&#123;</span><br><span class=\"line\">        console.log(this)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var b = a.fn;</span><br><span class=\"line\"></span><br><span class=\"line\">a.fn()//this指向a</span><br><span class=\"line\">b()//this指向window</span><br></pre></td></tr></table></figure>\n<p>3.构造函数实例化后this指向实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a()&#123;</span><br><span class=\"line\">    this.x = 1;</span><br><span class=\"line\">    console.log(this)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = new a();</span><br></pre></td></tr></table></figure>\n<p>4.使用函数的apply或call方法调用时，this指第一个参数</p>\n<h4 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h4><p>如果没有指定this的话它值是undefined</p>\n<h4 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h4><p>箭头函数中的this是箭头函数所处作用域中的this </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let self = this</span><br><span class=\"line\">() =&gt; &#123;</span><br><span class=\"line\">    console.log(this)//这里的this等价于self</span><br><span class=\"line\">    console.log(self)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;</span><br><span class=\"line\">    func: () =&gt; &#123;</span><br><span class=\"line\">        console.log(this === window); // true，非箭头函数时指向 obj</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.func();</span><br></pre></td></tr></table></figure>\n","categories":["前端"],"tags":["js"]},{"title":"socket.io简单使用","url":"https://zmkmb.github.io/2018/03/28/socket.io简单使用/","content":"<h2 id=\"socket-io的简单使用\"><a href=\"#socket-io的简单使用\" class=\"headerlink\" title=\"socket.io的简单使用\"></a>socket.io的简单使用</h2><p>socket.io提供了基于事件的实时双向通讯,它封装了websocket。同时在websocket不支持的情况下，使用ajax轮询的方式做兼容。<br><a id=\"more\"></a></p>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><ul>\n<li>客户端</li>\n</ul>\n<p>引入js</p>\n<ul>\n<li>服务端</li>\n</ul>\n<p>npm install –save socket.io</p>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><ul>\n<li>客户端 </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var io = io()</span><br><span class=\"line\">io.on(&apos;news&apos;,function(data)&#123;</span><br><span class=\"line\">    console.log(data)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>服务端</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require(&apos;express&apos;)</span><br><span class=\"line\">var socketIo = require(&apos;socket.io&apos;)</span><br><span class=\"line\">var app = express()</span><br><span class=\"line\">var server = require(&apos;http&apos;).Server(app)</span><br><span class=\"line\">var io = socketIo(server)</span><br><span class=\"line\">io.on(&apos;connection&apos;, function (socket) &#123;</span><br><span class=\"line\">    socket.emit(&apos;news&apos;,&#123;msg:&apos;helloWorld&apos;&#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8080)</span><br></pre></td></tr></table></figure>\n<h4 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api\"></a>api</h4><ul>\n<li>发给所有人</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">io.sockets.emit(&apos;news&apos;,data);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>除了自己以为的所有人</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">socket.broadcast.emit(&quot;news&quot;,data);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>发给某一个人</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">io.sockets.sockets[socketid]</span><br><span class=\"line\">或</span><br><span class=\"line\">io.sockets.connected[socketid]</span><br></pre></td></tr></table></figure>\n<h4 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">socket.on(&apos;group1&apos;, function (data) &#123;</span><br><span class=\"line\">        socket.join(&apos;group1&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">socket.on(&apos;group2&apos;,function(data)&#123;</span><br><span class=\"line\">        socket.join(&apos;group2&apos;);</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">客户端发送</span><br><span class=\"line\">socket.emit(‘group1’)，就可以加入group1分组；</span><br><span class=\"line\">socket.emit(‘group2’)，就可以加入group2分组；</span><br></pre></td></tr></table></figure>\n<ul>\n<li>对分组中的用户发送信息</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//不包括自己</span><br><span class=\"line\">socket.broadcast.to(&apos;group1&apos;).emit(&apos;event_name&apos;, data);</span><br><span class=\"line\">//包括自己</span><br><span class=\"line\">io.sockets.in(&apos;group1&apos;).emit(&apos;event_name&apos;, data);</span><br></pre></td></tr></table></figure>\n<h4 id=\"客户端socket-on-监听的事件\"><a href=\"#客户端socket-on-监听的事件\" class=\"headerlink\" title=\"客户端socket.on()监听的事件\"></a>客户端socket.on()监听的事件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connect：连接成功</span><br><span class=\"line\">connecting：正在连接</span><br><span class=\"line\">disconnect：断开连接</span><br><span class=\"line\">connect_failed：连接失败</span><br><span class=\"line\">error：错误发生，并且无法被其他事件类型所处理</span><br><span class=\"line\">message：同服务器端message事件</span><br><span class=\"line\">anything：同服务器端anything事件</span><br><span class=\"line\">reconnect_failed：重连失败</span><br><span class=\"line\">reconnect：成功重连</span><br><span class=\"line\">reconnecting：正在重连</span><br></pre></td></tr></table></figure>","categories":[],"tags":[]},{"title":"css 1像素问题","url":"https://zmkmb.github.io/2018/03/28/css1像素问题/","content":"<h3 id=\"为什么会出现1像素问题？\"><a href=\"#为什么会出现1像素问题？\" class=\"headerlink\" title=\"为什么会出现1像素问题？\"></a>为什么会出现1像素问题？</h3><p>高分辨率的手机，用多个物理像素表示css中的1px。</p>\n<p>我们打开谷歌浏览器，开启手机模拟模式，选择iphone6,可以看到iphone6的分辨率是375 <em> 667，但是iphone6屏幕的分辨率是750 </em> 1334。<br><a id=\"more\"></a><br>我们称 375 <em> 667 为逻辑像素,750 </em> 1334 为物理像素</p>\n<p>也就是说iphone6上，4个物理像素显示1个逻辑像素。<br>这样就导致我们用css声明的1px边框看起来显的粗一些，这并不是我们想看到。</p>\n<h3 id=\"如何解决？\"><a href=\"#如何解决？\" class=\"headerlink\" title=\"如何解决？\"></a>如何解决？</h3><ul>\n<li>ios8以上的版本支持0.5px</li>\n</ul>\n<p>缺点：存在兼容性问题</p>\n<ul>\n<li><p>设置 border-image</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.border-image-1px &#123;</span><br><span class=\"line\">    border-width: 1px 0px;</span><br><span class=\"line\">    border-image: url(&quot;data:image/png;base64,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&quot;) 2 0 stretch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>伪元素缩放</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.div::after &#123;</span><br><span class=\"line\">    content: &apos;&apos;;</span><br><span class=\"line\">    width: 200%;</span><br><span class=\"line\">    height: 200%;</span><br><span class=\"line\">    position: absolute;</span><br><span class=\"line\">    top: 0;</span><br><span class=\"line\">    left: 0;</span><br><span class=\"line\">    border: 1px solid #bfbfbf;</span><br><span class=\"line\">    border-radius: 4px;</span><br><span class=\"line\">    -webkit-transform: scale(0.5,0.5);</span><br><span class=\"line\">    transform: scale(0.5,0.5);</span><br><span class=\"line\">    -webkit-transform-origin: top left;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>页面整体缩放</li>\n</ul>\n","categories":[],"tags":["css"]},{"title":"js中instanceof用法","url":"https://zmkmb.github.io/2018/03/28/js中instanceof用法/","content":"<h2 id=\"js中instanceof用法\"><a href=\"#js中instanceof用法\" class=\"headerlink\" title=\"js中instanceof用法\"></a>js中instanceof用法</h2><p>在 JavaScript 中，判断一个变量的类型尝尝会用 typeof 运算符，在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 “object”。ECMAScript 引入了另一个 Java 运算符 instanceof 来解决这个问题。<br><a id=\"more\"></a></p>\n<ul>\n<li>简单使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 判断 foo 是否是 Foo 类的实例</span><br><span class=\"line\">function Foo()&#123;&#125; </span><br><span class=\"line\">var foo = new Foo(); </span><br><span class=\"line\">console.log(foo instanceof Foo)//true</span><br></pre></td></tr></table></figure>\n<ul>\n<li>实现一个instanceof<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function instance_of(L, R) &#123;//L 表示左表达式，R 表示右表达式</span><br><span class=\"line\"> var O = R.prototype;// 取 R 的显示原型</span><br><span class=\"line\"> L = L.__proto__;// 取 L 的隐式原型</span><br><span class=\"line\"> while (true) &#123; </span><br><span class=\"line\">   if (L === null) </span><br><span class=\"line\">     return false; </span><br><span class=\"line\">   if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true </span><br><span class=\"line\">     return true; </span><br><span class=\"line\">   L = L.__proto__; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","categories":["前端"],"tags":["js"]},{"title":"async和defer的区别","url":"https://zmkmb.github.io/2018/03/28/async和defer的区别/","content":"<h2 id=\"async和defer的区别\"><a href=\"#async和defer的区别\" class=\"headerlink\" title=\"async和defer的区别\"></a>async和defer的区别</h2><h5 id=\"怎么使用？\"><a href=\"#怎么使用？\" class=\"headerlink\" title=\"怎么使用？\"></a>怎么使用？</h5><p>async和defer用在script标签当中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script async src=&apos;1.js&apos;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script defer src=&apos;2.js&apos;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"有什么用？\"><a href=\"#有什么用？\" class=\"headerlink\" title=\"有什么用？\"></a>有什么用？</h5><a id=\"more\"></a>\n<p>正常情况下浏览器在解析到script标签时，渲染进程会停止解析html,而去先加载,解析并执行js。原因是js可能改变DOM结构。</p>\n<p>如果script标签上加上async或defer属性，浏览器就会异步的加载和执行js代码，而不会阻塞渲染。</p>\n<h5 id=\"有什么区别？\"><a href=\"#有什么区别？\" class=\"headerlink\" title=\"有什么区别？\"></a>有什么区别？</h5><p>async和defer,都是异步加载js,区别在于js下载完成后何时执行</p>\n<ul>\n<li>async</li>\n</ul>\n<p>js加载完就执行，js执行顺序不固定</p>\n<ul>\n<li>defer</li>\n</ul>\n<p>js执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。js按照加载顺序执行。</p>\n<h5 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h5><p>为了防止js加载阻塞页面渲染。<br>实践中，js脚本一般会放在 之前。</p>\n","categories":["前端"],"tags":["js"]},{"title":"编译安装nginx","url":"https://zmkmb.github.io/2018/03/09/编译安装nginx/","content":"<p>编译时报错</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src/core/ngx_murmurhash.c:37:11: error: this statement may fall through [-Werror=implicit-fallthrough</span><br><span class=\"line\">h = data[2] &lt;&lt; 16;</span><br><span class=\"line\">~</span><br><span class=\"line\">src/core/ngx_murmurhash.c:38:5: note: here</span><br><span class=\"line\">case 2:</span><br><span class=\"line\">~</span><br><span class=\"line\"></span><br><span class=\"line\">src/core/ngx_murmurhash.c:39:11: error: this statement may fall through [-Werror=implicit-fallthrough=]</span><br><span class=\"line\">h = data[1] &lt;&lt; 8;</span><br><span class=\"line\"></span><br><span class=\"line\">src/core/ngx_murmurhash.c:40:5: note: here</span><br><span class=\"line\">case 1:</span><br></pre></td></tr></table></figure>\n<p>gcc 7 版本会有这样的错误，切换gcc版本就好了。</p>\n","categories":[],"tags":["nginx"]},{"title":"tag","url":"https://zmkmb.github.io/tag/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"https://zmkmb.github.io/search/index.html","content":"","categories":[],"tags":[]},{"title":"about","url":"https://zmkmb.github.io/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"https://zmkmb.github.io/category/index.html","content":"","categories":[],"tags":[]}]